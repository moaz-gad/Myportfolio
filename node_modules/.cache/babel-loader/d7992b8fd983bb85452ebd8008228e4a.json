{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**** stylesheet  ****/\n\nimport { StyleSheet } from './sheet.js';\nimport { createMarkupForStyles } from './CSSPropertyOperations';\nimport clean from './clean.js';\nexport var styleSheet = new StyleSheet();\n// an isomorphic StyleSheet shim. hides all the nitty gritty. \n\n// /**************** LIFTOFF IN 3... 2... 1... ****************/\nstyleSheet.inject(); //eslint-disable-line indent\n// /****************      TO THE MOOOOOOON     ****************/\n\n// convenience function to toggle speedy\nexport function speedy(bool) {\n  return styleSheet.speedy(bool);\n}\n\n// plugins \nimport { PluginSet, prefixes, fallbacks, bug20fix } from './plugins'; // we include these by default \nexport var plugins = styleSheet.plugins = new PluginSet(fallbacks, bug20fix, prefixes);\nplugins.media = new PluginSet(); // neat! media, font-face, keyframes\nplugins.fontFace = new PluginSet();\nplugins.keyframes = new PluginSet(prefixes);\n\n// define some constants \nvar isBrowser = typeof window !== 'undefined';\nvar isDev = function (x) {\n  return x === 'development' || !x;\n}(process.env.NODE_ENV);\nvar isTest = process.env.NODE_ENV === 'test';\n\n/**** simulations  ****/\n\n// a flag to enable simulation meta tags on dom nodes \n// defaults to true in dev mode. recommend *not* to \n// toggle often. \nvar canSimulate = isDev;\n\n// we use these flags for issuing warnings when simulate is called \n// in prod / in incorrect order \nvar warned1 = false,\n  warned2 = false;\n\n// toggles simulation activity. shouldn't be needed in most cases \nexport function simulations() {\n  var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  canSimulate = !!bool;\n}\n\n// use this on dom nodes to 'simulate' pseudoclasses\n// <div {...hover({ color: 'red' })} {...simulate('hover', 'visited')}>...</div>\n// you can even send in some weird ones, as long as it's in simple format \n// and matches an existing rule on the element \n// eg simulate('nthChild2', ':hover:active') etc \nexport function simulate() {\n  for (var _len = arguments.length, pseudos = Array(_len), _key = 0; _key < _len; _key++) {\n    pseudos[_key] = arguments[_key];\n  }\n  pseudos = clean(pseudos);\n  if (!pseudos) return {};\n  if (!canSimulate) {\n    if (!warned1) {\n      console.warn('can\\'t simulate without once calling simulations(true)'); //eslint-disable-line no-console\n      warned1 = true;\n    }\n    if (!isDev && !isTest && !warned2) {\n      console.warn('don\\'t use simulation outside dev'); //eslint-disable-line no-console\n      warned2 = true;\n    }\n    return {};\n  }\n  return pseudos.reduce(function (o, p) {\n    return o['data-simulate-' + simple(p)] = '', o;\n  }, {});\n}\n\n/**** labels ****/\n// toggle for debug labels. \n// *shouldn't* have to mess with this manually\nvar hasLabels = isDev;\nexport function cssLabels(bool) {\n  hasLabels = !!bool;\n}\n\n// takes a string, converts to lowercase, strips out nonalphanumeric.\nfunction simple(str) {\n  return str.toLowerCase().replace(/[^a-z0-9]/g, '');\n}\n\n// flatten a nested array \nfunction flatten(inArr) {\n  var arr = [];\n  for (var i = 0; i < inArr.length; i++) {\n    if (Array.isArray(inArr[i])) arr = arr.concat(flatten(inArr[i]));else arr = arr.concat(inArr[i]);\n  }\n  return arr;\n}\n\n// hashes a string to something 'unique'\n// we use this to generate ids for styles\nimport hash from './hash';\nfunction hashify() {\n  for (var _len2 = arguments.length, objs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    objs[_key2] = arguments[_key2];\n  }\n  return hash(objs.map(function (x) {\n    return JSON.stringify(x);\n  }).join('')).toString(36);\n}\n\n// of shape { 'data-css-<id>': ''}\nexport function isLikeRule(rule) {\n  var keys = Object.keys(rule).filter(function (x) {\n    return x !== 'toString';\n  });\n  if (keys.length !== 1) {\n    return false;\n  }\n  return !!/data\\-css\\-([a-zA-Z0-9]+)/.exec(keys[0]);\n}\n\n// extracts id from a { 'data-css-<id>': ''} like object \nexport function idFor(rule) {\n  var keys = Object.keys(rule).filter(function (x) {\n    return x !== 'toString';\n  });\n  if (keys.length !== 1) throw new Error('not a rule');\n  var regex = /data\\-css\\-([a-zA-Z0-9]+)/;\n  var match = regex.exec(keys[0]);\n  if (!match) throw new Error('not a rule');\n  return match[1];\n}\n\n// a simple cache to store generated rules \nvar registered = styleSheet.registered = {};\nfunction register(spec) {\n  if (!registered[spec.id]) {\n    registered[spec.id] = spec;\n  }\n}\n\n// semi-deeply merge 2 'mega' style objects \nfunction deepMergeStyles(dest, src) {\n  Object.keys(src).forEach(function (expr) {\n    dest[expr] = dest[expr] || {};\n    Object.keys(src[expr]).forEach(function (type) {\n      dest[expr][type] = dest[expr][type] || {};\n      Object.assign(dest[expr][type], src[expr][type]);\n    });\n  });\n}\n\n//todo - prevent nested media queries\nfunction deconstruct(obj) {\n  var ret = [];\n  var plain = {},\n    hasPlain = false;\n  var hasPseudos = obj && find(Object.keys(obj), function (x) {\n    return x.charAt(0) === ':';\n  });\n  var hasMedias = obj && find(Object.keys(obj), function (x) {\n    return x.charAt(0) === '@';\n  }); // todo - check @media\n  var hasSelects = obj && find(Object.keys(obj), function (x) {\n    return x.indexOf('&') >= 0;\n  });\n  if (hasPseudos || hasMedias || hasSelects) {\n    Object.keys(obj).forEach(function (key) {\n      if (key.charAt(0) === ':') {\n        ret.push({\n          type: 'pseudo',\n          style: obj[key],\n          selector: key\n        });\n      } else if (key.charAt(0) === '@') {\n        ret.push({\n          type: 'media',\n          rules: deconstruct(obj[key]),\n          expr: key.substring(6)\n        });\n      } else if (key.indexOf('&') >= 0) {\n        ret.push({\n          type: 'select',\n          style: obj[key],\n          selector: key\n        });\n      } else {\n        hasPlain = true;\n        plain[key] = obj[key];\n      }\n    });\n    return hasPlain ? [plain].concat(ret) : ret;\n  }\n  return obj;\n}\n\n// extracts and composes styles from a rule into a 'mega' style\n// with sub styles keyed by media query + 'path'\nfunction extractStyles() {\n  for (var _len3 = arguments.length, rules = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    rules[_key3] = arguments[_key3];\n  }\n  rules = flatten(rules);\n  var exprs = {};\n  // converts {[data-css-<id>]} to the backing rule \n  rules = rules.map(function (x) {\n    return isLikeRule(x) ? registered[idFor(x)] : x;\n  }).map(function (x) {\n    return x.type === 'style' || !x.type ? deconstruct(x.style || x) : x;\n  });\n  rules = flatten(rules);\n  rules.forEach(function (rule) {\n    // avoid possible label. todo - cleaner \n    if (typeof rule === 'string') {\n      return;\n    }\n    switch (rule.type) {\n      case 'raw':\n        throw new Error('not implemented');\n      case 'font-face':\n        throw new Error('not implemented');\n      case 'keyframes':\n        throw new Error('not implemented');\n      case 'merge':\n        return deepMergeStyles(exprs, extractStyles(rule.rules));\n      case 'pseudo':\n        if (rule.selector === ':hover' && exprs._ && exprs._['%%%:active'] && !exprs._['%%%:hover']) {\n          console.warn(':active must come after :hover to work correctly'); //eslint-disable-line no-console\n        }\n\n        return deepMergeStyles(exprs, {\n          _: _defineProperty({}, '%%%' + rule.selector, rule.style)\n        });\n      case 'select':\n        return deepMergeStyles(exprs, {\n          _: _defineProperty({}, '^^^' + rule.selector, rule.style)\n        });\n      case 'parent':\n        return deepMergeStyles(exprs, {\n          _: _defineProperty({}, '***' + rule.selector, rule.style)\n        });\n      case 'style':\n        return deepMergeStyles(exprs, {\n          _: {\n            _: rule.style\n          }\n        });\n      case 'media':\n        return deepMergeStyles(exprs, _defineProperty({}, rule.expr, extractStyles(rule.rules)._));\n      default:\n        return deepMergeStyles(exprs, {\n          _: {\n            _: rule\n          }\n        });\n    }\n  });\n  return exprs;\n}\n\n// extract label from a rule / style \nfunction extractLabel(rule) {\n  if (isLikeRule(rule)) {\n    rule = registered[idFor(rule)];\n  }\n  return rule.label || '{:}';\n}\n\n// given an id / 'path', generate a css selector \nfunction selector(id, path) {\n  if (path === '_') return '.css-' + id + ',[data-css-' + id + ']';\n  if (path.indexOf('%%%') === 0) {\n    var x = '.css-' + id + path.slice(3) + ',[data-css-' + id + ']' + path.slice(3);\n    if (canSimulate) x += ',.css-' + id + '[data-simulate-' + simple(path) + '],[data-css-' + id + '][data-simulate-' + simple(path) + ']';\n    return x;\n  }\n  if (path.indexOf('***') === 0) {\n    return path.slice(3).split(',').map(function (x) {\n      return x + ' .css-' + id + ',' + x + ' [data-css-' + id + ']';\n    }).join(',');\n  }\n  if (path.indexOf('^^^') === 0) {\n    return path.slice(3).split(',').map(function (x) {\n      return x.indexOf('&') >= 0 ? [x.replace(/\\&/mg, '.css-' + id), x.replace(/\\&/mg, '[data-css-' + id + ']')].join(',') // todo - make sure each sub selector has an &\n      : '.css-' + id + x + ',[data-css-' + id + ']' + x;\n    }).join(',');\n  }\n}\nfunction toCSS(_ref4) {\n  var selector = _ref4.selector;\n  var style = _ref4.style;\n  var result = plugins.transform({\n    selector: selector,\n    style: style\n  });\n  return result.selector + '{' + createMarkupForStyles(result.style) + '}';\n}\nfunction ruleToAst(rule) {\n  var styles = extractStyles(rule);\n  return Object.keys(styles).reduce(function (o, expr) {\n    o[expr] = Object.keys(styles[expr]).map(function (s) {\n      return {\n        selector: selector(rule.id, s),\n        style: styles[expr][s]\n      };\n    });\n    return o;\n  }, {});\n}\nfunction ruleToCSS(spec) {\n  var css = [];\n  var ast = ruleToAst(spec);\n  // plugins here \n  var _ = ast._;\n  var exprs = _objectWithoutProperties(ast, ['_']);\n  if (_) {\n    _.map(toCSS).forEach(function (str) {\n      return css.push(str);\n    });\n  }\n  Object.keys(exprs).forEach(function (expr) {\n    css.push('@media ' + expr + '{' + exprs[expr].map(toCSS).join('') + '}');\n  });\n  return css;\n}\n\n// this cache to track which rules have \n// been inserted into the stylesheet\nvar inserted = styleSheet.inserted = {};\n\n// and helpers to insert rules into said styleSheet\nfunction insert(spec) {\n  if (!inserted[spec.id]) {\n    inserted[spec.id] = true;\n    ruleToCSS(spec).map(function (cssRule) {\n      return styleSheet.insert(cssRule);\n    });\n  }\n}\nexport function insertRule(css) {\n  var spec = {\n    id: hashify(css),\n    css: css,\n    type: 'raw',\n    label: '^'\n  };\n  register(spec);\n  if (!inserted[spec.id]) {\n    styleSheet.insert(spec.css);\n    inserted[spec.id] = true;\n  }\n}\nexport function insertGlobal(selector, style) {\n  return insertRule(selector + '{' + createMarkupForStyles(style) + '}');\n}\nfunction insertKeyframe(spec) {\n  if (!inserted[spec.id]) {\n    (function () {\n      var inner = Object.keys(spec.keyframes).map(function (kf) {\n        var result = plugins.keyframes.transform({\n          id: spec.id,\n          name: kf,\n          style: spec.keyframes[kf]\n        });\n        return result.name + '{' + createMarkupForStyles(result.style) + '}';\n      }).join('');\n      ['-webkit-', '-moz-', '-o-', ''].forEach(function (prefix) {\n        return styleSheet.insert('@' + prefix + 'keyframes ' + (spec.name + '_' + spec.id) + '{' + inner + '}');\n      });\n      inserted[spec.id] = true;\n    })();\n  }\n}\nfunction insertFontFace(spec) {\n  if (!inserted[spec.id]) {\n    styleSheet.insert('@font-face{' + createMarkupForStyles(spec.font) + '}');\n    inserted[spec.id] = true;\n  }\n}\n\n// rehydrate the insertion cache with ids sent from \n// renderStatic / renderStaticOptimized \nexport function rehydrate(ids) {\n  // load up ids\n  Object.assign(inserted, ids.reduce(function (o, i) {\n    return o[i] = true, o;\n  }, {}));\n  // assume css loaded separately\n}\n\n// todo - perf\nvar ruleCache = {};\nfunction toRule(spec) {\n  register(spec);\n  insert(spec);\n  if (ruleCache[spec.id]) {\n    return ruleCache[spec.id];\n  }\n  var ret = _defineProperty({}, 'data-css-' + spec.id, hasLabels ? spec.label || '' : '');\n  Object.defineProperty(ret, 'toString', {\n    enumerable: false,\n    value: function value() {\n      return 'css-' + spec.id;\n    }\n  });\n  ruleCache[spec.id] = ret;\n  return ret;\n}\n\n// clears out the cache and empties the stylesheet\n// best for tests, though there might be some value for SSR. \n\nexport function flush() {\n  inserted = styleSheet.inserted = {};\n  registered = styleSheet.registered = {};\n  ruleCache = {};\n  styleSheet.flush();\n  styleSheet.inject();\n}\nfunction find(arr, fn) {\n  for (var i = 0; i < arr.length; i++) {\n    if (fn(arr[i]) === true) {\n      return true;\n    }\n  }\n  return false;\n}\nexport function style(obj) {\n  obj = clean(obj);\n  return obj ? toRule({\n    id: hashify(obj),\n    type: 'style',\n    style: obj,\n    label: obj.label || '*'\n  }) : {};\n}\n\n// unique feature \n// when you need to define 'real' css (whatever that may be)\n// https://twitter.com/threepointone/status/756585907877273600\n// https://twitter.com/threepointone/status/756986938033254400\nexport function select(selector, obj) {\n  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {\n    return style(selector);\n  }\n  obj = clean(obj);\n  return obj ? toRule({\n    id: hashify(selector, obj),\n    type: 'select',\n    selector: selector,\n    style: obj,\n    label: obj.label || '*'\n  }) : {};\n}\nexport var $ = select; // bringin' jquery back\n\nexport function parent(selector, obj) {\n  obj = clean(obj);\n  return obj ? toRule({\n    id: hashify(selector, obj),\n    type: 'parent',\n    selector: selector,\n    style: obj,\n    label: obj.label || '*'\n  }) : {};\n}\n\n// we define a function to 'merge' styles together.\n// backstory - because of a browser quirk, multiple styles are applied in the order they're \n// defined in the stylesheet, not in the order of application \n// in most cases, this won't case an issue UNTIL IT DOES \n// instead, use merge() to merge styles,\n// with latter styles gaining precedence over former ones \n\nexport function merge() {\n  for (var _len4 = arguments.length, rules = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    rules[_key4] = arguments[_key4];\n  }\n  rules = clean(rules);\n  return rules ? toRule({\n    id: hashify(extractStyles(rules)),\n    type: 'merge',\n    rules: rules,\n    label: '[' + (typeof rules[0] === 'string' ? rules[0] : rules.map(extractLabel).join(' + ')) + ']'\n  }) : {};\n}\nexport var compose = merge;\nexport function media(expr) {\n  for (var _len5 = arguments.length, rules = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    rules[_key5 - 1] = arguments[_key5];\n  }\n  rules = clean(rules);\n  return rules ? toRule({\n    id: hashify(expr, extractStyles(rules)),\n    type: 'media',\n    rules: rules,\n    expr: expr,\n    label: '*mq(' + rules.map(extractLabel).join(' + ') + ')'\n  }) : {};\n}\nexport var presets = {\n  mobile: '(min-width: 400px)',\n  phablet: '(min-width: 550px)',\n  tablet: '(min-width: 750px)',\n  desktop: '(min-width: 1000px)',\n  hd: '(min-width: 1200px)'\n};\n\n/**** live media query labels ****/\n\n// simplest implementation -\n// cycle through the cache, and for every media query\n// find matching elements and update the label \nfunction updateMediaQueryLabels() {\n  Object.keys(registered).forEach(function (id) {\n    var expr = registered[id].expr;\n    if (expr && hasLabels && window.matchMedia) {\n      (function () {\n        var els = document.querySelectorAll('[data-css-' + id + ']');\n        var match = window.matchMedia(expr).matches ? '✓' : '✕';\n        var regex = /^(✓|✕|\\*)mq/;\n        [].concat(_toConsumableArray(els)).forEach(function (el) {\n          return el.setAttribute('data-css-' + id, el.getAttribute('data-css-' + id).replace(regex, match + 'mq'));\n        });\n      })();\n    }\n  });\n}\n\n// saves a reference to the loop we trigger \nvar interval = void 0;\nexport function trackMediaQueryLabels() {\n  var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;\n  if (bool) {\n    if (interval) {\n      console.warn('already tracking labels, call trackMediaQueryLabels(false) to stop'); // eslint-disable-line no-console \n      return;\n    }\n    interval = setInterval(function () {\n      return updateMediaQueryLabels();\n    }, period);\n  } else {\n    clearInterval(interval);\n    interval = null;\n  }\n}\n\n// in dev mode, start this up immediately \nif (isDev && isBrowser) {\n  trackMediaQueryLabels(true);\n  // todo - make sure hot loading isn't broken\n  // todo - clearInterval on browser close  \n}\n\nexport function pseudo(selector, obj) {\n  obj = clean(obj);\n  return obj ? toRule({\n    id: hashify(selector, obj),\n    type: 'pseudo',\n    selector: selector,\n    style: obj,\n    label: obj.label || ':*'\n  }) : {};\n}\n\n// allllll the pseudoclasses\n\nexport function active(x) {\n  return pseudo(':active', x);\n}\nexport function any(x) {\n  return pseudo(':any', x);\n}\nexport function checked(x) {\n  return pseudo(':checked', x);\n}\nexport function disabled(x) {\n  return pseudo(':disabled', x);\n}\nexport function empty(x) {\n  return pseudo(':empty', x);\n}\nexport function enabled(x) {\n  return pseudo(':enabled', x);\n}\nexport function _default(x) {\n  return pseudo(':default', x); // note '_default' name  \n}\n\nexport function first(x) {\n  return pseudo(':first', x);\n}\nexport function firstChild(x) {\n  return pseudo(':first-child', x);\n}\nexport function firstOfType(x) {\n  return pseudo(':first-of-type', x);\n}\nexport function fullscreen(x) {\n  return pseudo(':fullscreen', x);\n}\nexport function focus(x) {\n  return pseudo(':focus', x);\n}\nexport function hover(x) {\n  return pseudo(':hover', x);\n}\nexport function indeterminate(x) {\n  return pseudo(':indeterminate', x);\n}\nexport function inRange(x) {\n  return pseudo(':in-range', x);\n}\nexport function invalid(x) {\n  return pseudo(':invalid', x);\n}\nexport function lastChild(x) {\n  return pseudo(':last-child', x);\n}\nexport function lastOfType(x) {\n  return pseudo(':last-of-type', x);\n}\nexport function left(x) {\n  return pseudo(':left', x);\n}\nexport function link(x) {\n  return pseudo(':link', x);\n}\nexport function onlyChild(x) {\n  return pseudo(':only-child', x);\n}\nexport function onlyOfType(x) {\n  return pseudo(':only-of-type', x);\n}\nexport function optional(x) {\n  return pseudo(':optional', x);\n}\nexport function outOfRange(x) {\n  return pseudo(':out-of-range', x);\n}\nexport function readOnly(x) {\n  return pseudo(':read-only', x);\n}\nexport function readWrite(x) {\n  return pseudo(':read-write', x);\n}\nexport function required(x) {\n  return pseudo(':required', x);\n}\nexport function right(x) {\n  return pseudo(':right', x);\n}\nexport function root(x) {\n  return pseudo(':root', x);\n}\nexport function scope(x) {\n  return pseudo(':scope', x);\n}\nexport function target(x) {\n  return pseudo(':target', x);\n}\nexport function valid(x) {\n  return pseudo(':valid', x);\n}\nexport function visited(x) {\n  return pseudo(':visited', x);\n}\n\n// parameterized pseudoclasses\nexport function dir(p, x) {\n  return pseudo(':dir(' + p + ')', x);\n}\nexport function lang(p, x) {\n  return pseudo(':lang(' + p + ')', x);\n}\nexport function not(p, x) {\n  // should this be a plugin?\n  var selector = p.split(',').map(function (x) {\n    return x.trim();\n  }).map(function (x) {\n    return ':not(' + x + ')';\n  });\n  if (selector.length === 1) {\n    return pseudo(':not(' + p + ')', x);\n  }\n  return select(selector.join(''), x);\n}\nexport function nthChild(p, x) {\n  return pseudo(':nth-child(' + p + ')', x);\n}\nexport function nthLastChild(p, x) {\n  return pseudo(':nth-last-child(' + p + ')', x);\n}\nexport function nthLastOfType(p, x) {\n  return pseudo(':nth-last-of-type(' + p + ')', x);\n}\nexport function nthOfType(p, x) {\n  return pseudo(':nth-of-type(' + p + ')', x);\n}\n\n// pseudoelements\nexport function after(x) {\n  return pseudo('::after', x);\n}\nexport function before(x) {\n  return pseudo('::before', x);\n}\nexport function firstLetter(x) {\n  return pseudo('::first-letter', x);\n}\nexport function firstLine(x) {\n  return pseudo('::first-line', x);\n}\nexport function selection(x) {\n  return pseudo('::selection', x);\n}\nexport function backdrop(x) {\n  return pseudo('::backdrop', x);\n}\nexport function placeholder(x) {\n  // https://github.com/threepointone/glamor/issues/14\n  return merge(pseudo('::placeholder', x), pseudo('::-webkit-input-placeholder', x), pseudo('::-moz-placeholder', x), pseudo('::-ms-input-placeholder', x));\n}\n\n// we can add keyframes in a similar manner, but still generating a unique name \n// for including in styles. this gives us modularity, but still a natural api \nexport function keyframes(name, kfs) {\n  if (!kfs) {\n    kfs = name, name = 'animation';\n  }\n\n  // do not ignore empty keyframe definitions for now.\n  kfs = clean(kfs) || {};\n  var spec = {\n    id: hashify(name, kfs),\n    type: 'keyframes',\n    name: name,\n    keyframes: kfs\n  };\n  register(spec);\n  insertKeyframe(spec);\n  return name + '_' + spec.id;\n}\n\n// we don't go all out for fonts as much, giving a simple font loading strategy \n// use a fancier lib if you need moar power\nexport function fontFace(font) {\n  font = clean(font);\n  var spec = {\n    id: hashify(font),\n    type: 'font-face',\n    font: font\n  };\n  register(spec);\n  insertFontFace(spec);\n  return font.fontFamily;\n}\n\n/*** helpers for web components ***/\n// https://github.com/threepointone/glamor/issues/16\n\nexport function cssFor() {\n  for (var _len6 = arguments.length, rules = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    rules[_key6] = arguments[_key6];\n  }\n  rules = clean(rules);\n  return rules ? flatten(rules.map(function (r) {\n    return registered[idFor(r)];\n  }).map(ruleToCSS)).join('') : '';\n}\nexport function attribsFor() {\n  for (var _len7 = arguments.length, rules = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    rules[_key7] = arguments[_key7];\n  }\n  rules = clean(rules);\n  var htmlAttributes = rules ? rules.map(function (rule) {\n    idFor(rule); // throwaway check for rule \n    var key = Object.keys(rule)[0],\n      value = rule[key];\n    return key + '=\"' + (value || '') + '\"';\n  }).join(' ') : '';\n  return htmlAttributes;\n}","map":null,"metadata":{},"sourceType":"module"}