{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar isDev = function (x) {\n  return x === 'development' || !x;\n}(process.env.NODE_ENV);\nexport var PluginSet = function () {\n  function PluginSet() {\n    _classCallCheck(this, PluginSet);\n    for (var _len = arguments.length, initial = Array(_len), _key = 0; _key < _len; _key++) {\n      initial[_key] = arguments[_key];\n    }\n    this.fns = initial || [];\n  }\n  _createClass(PluginSet, [{\n    key: 'add',\n    value: function add() {\n      var _this = this;\n      for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        fns[_key2] = arguments[_key2];\n      }\n      fns.forEach(function (fn) {\n        if (_this.fns.indexOf(fn) >= 0) {\n          if (isDev) {\n            console.warn('adding the same plugin again, ignoring'); //eslint-disable-line no-console\n          }\n        } else {\n          _this.fns = [fn].concat(_toConsumableArray(_this.fns));\n        }\n      });\n    }\n  }, {\n    key: 'remove',\n    value: function remove(fn) {\n      this.fns = this.fns.filter(function (x) {\n        return x !== fn;\n      });\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.fns = [];\n    }\n  }, {\n    key: 'transform',\n    value: function transform(o) {\n      return this.fns.reduce(function (o, fn) {\n        return fn(o);\n      }, o);\n    }\n  }]);\n  return PluginSet;\n}();\nexport function fallbacks(node) {\n  var hasArray = Object.keys(node.style).map(function (x) {\n    return Array.isArray(node.style[x]);\n  }).indexOf(true) >= 0;\n  if (hasArray) {\n    var _ret = function () {\n      var style = node.style;\n      var rest = _objectWithoutProperties(node, ['style']);\n      var flattened = Object.keys(style).reduce(function (o, key) {\n        o[key] = Array.isArray(style[key]) ? style[key].join('; ' + key + ': ') : style[key];\n        return o;\n      }, {});\n      // todo - \n      // flatten arrays which haven't been flattened yet \n      return {\n        v: _extends({\n          style: flattened\n        }, rest)\n      };\n    }();\n    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n  }\n  return node;\n}\nimport { autoprefix } from './autoprefix';\nexport function prefixes(_ref) {\n  var style = _ref.style;\n  var rest = _objectWithoutProperties(_ref, ['style']);\n  return _extends({\n    style: autoprefix(style)\n  }, rest);\n}\nexport function bug20fix(_ref2) {\n  var selector = _ref2.selector;\n  var style = _ref2.style;\n\n  // https://github.com/threepointone/glamor/issues/20\n  // todo - only on chrome versions and server side   \n  return {\n    selector: selector.replace(/\\:hover/g, ':hover:nth-child(n)'),\n    style: style\n  };\n}","map":null,"metadata":{},"sourceType":"module"}